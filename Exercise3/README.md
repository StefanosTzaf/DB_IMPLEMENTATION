# Εργασία 3: Υλοποίηση Εξωτερικής Ταξινόμησης με Συγχώνευση

## Περιγραφή
    Η συγκεκριμένη εργασία στοχεύει στην υλοποίηση του αλγορίθμου εξωτερικής ταξινόμησης με συγχώνευση. Περιλαμβάνει τη χρήση και επέκταση βιβλιοθηκών που αναπτύχθηκαν στις 2 προηγούμενες εργασίες, όπως η HP_ και η BF_. Η εργασία αξιοποιεί το γλωσσικό μοντέλο ChatGPT για τη συγγραφή και υποστήριξη του κώδικα.

## Αρχεία που υλοποιήθηκαν
- **src/**: Αρχεία πηγαίου κώδικα (`.c`) και συγκεκριμένα τα:
    1. **sort.c**
    2. **merge.c**
    3. **chunk.c**
    Τα οποία ελέγχονται από το αρχείο με την συνάρτηση main: **sort_main.c** το οποίο δόθηκε από τον καθηγητή.

## Σχεδιαστικές Επιλογές & Παραδοχές
- **Ο σύνδεσμος της συζήτησής μας με το Chatgpt:**
    https://chatgpt.com/share/678038e2-12ac-8002-8d92-b9a9afc6d7fe
- **Η πορεία της συζήτησης:**
    Αρχικά δόθηκαν τα αρχεία της εκφώνησης της εργασίας, και των τριών .c αρχείων που οφείλαμε να υλοποιήσουμε. Ήδη από την πρώτη απάντηση που λάβαμε
    φάνηκε πως ο κώδικας έχει errors, κυρίως στο πέρασμα μεταβλητών στις συναρτήσεις που χρησιμοποιούσε, αλλά με την κατάλληλη καθοδήγηση και παρατηρητικότητα από πλευράς μας γρήγορα εξαλείφθηκαν και το πρόγραμμα, έστω για να δούμε πως τρέχει, ήταν σε θέση να εκτελεστεί. Προφανώς εμφανίστηκαν νέα προβλήματα στις αρχικές εκτελέσεις: *BF Error: The file can not be closed because there are available pin blocks* το οποίο λύθηκε με τα κατάλληλα unpin. Μετά από αρκετές εκτελέσεις και εκτυπώσεις των εγγραφών, η υλοποίηση του αρχείου sort.c φάνηκε να λειτουργεί σωστά. Στη συνέχεια λάβαμε και την νέα sort_main.c, γεγονός που βοήθηκε πολύ με το debugging κυρίως των merge.c και chunk.c αρχείων. Η στιχομυθία που ακολούθησε με το chatgpt αφορούσε προβλήματα με το που αρχίζει και που τελειώνει ενα chunk (σε ποιο block), παραβίαση ορίων με τους δείκτες & iterators, δημιουργία του ίδιου chunk ξανά και ξανά, και ατέρμονες βρόχοι. Από ένα σημείο και μετά που δεν βελτιωνόταν η κατάσταση, αφαιρέσαμε τα printf που πρότεινε το chatgpt για debugging, ώστε να καθαρίσει το output, και παρατηρήσαμε την πορεία του κώδικα για τυχών λάθη ή επιπολαιότητες που είχαν παραχθεί από τη συζήτηση. Τελικά τα προβλήματα λύθηκαν και παράγονται τα επιθυμητά αποτελέσματα.
- **Οι τροποποιήσεις μας πάνω στις υλοποιήσεις του Chatgpt:**
    1. **merge.c:**
        a. **Διαχείρηση μνήμης:**
        Ο προτεινόμενος κώδικας του chatgpt χρησιμοποιούσε στατικούς πίνακες CHUNK_Iterator chunkIterators[bWay], CHUNK chunks[bWay], κλπ. 
        Η τελική μας υλοποίηση κάνει δυναμική διαχείρηση μνήμης με κατάλληλες malloc και free, που βοηθά στο δεδομένο πρόβλημα με το μεταβαλλόμενο chunk size.
        b. **Chunk Iterators:**
        Η πρόταση του chatgpt δημιουργούσε bway αριθμό iterators όπου ο καθένας λειτουργούσε ανεξάρτητα, στη δική μας υλοποίηση έχουμε έναν iterator που δημιουργεί bway αριθμό chunks, πράγμα πολύ πιο λογικό, αποδοτικό και ταιριαστό στο δεδομένο αλγόριθμο που θέλει να ταξινομεί σε groups.
        c. **Συγχώνευση:**
        Η προτεινόμενη λύση του chatgpt έχει ένα main merge loop, στο οποίο γινόταν κακή διαχείρηση των chunks και των iterators, η τελική μας υλοποίηση έχει εμφωλευμένο το merge loop, με το εξωτερικό να ελέγχει την διαθεσιμότητα παραπάνω chunks. Κάπως έτσι ξεπεράσαμε τον ατέρμον βρόχο που προέκυπτε συνεχώς.
    2. **chunk.c:**
        a. **Λανθασμένη χρήση blockID & Chunk Iterator:**
        Ο κώδικας του chatgpt σε πολλά σημεία που θα έπρεπε να αναφέρεται σε blockID, χρησιμοποιούσε iterator->current και το αντίθετο, με αποτέλεσμα να μην υλοποιείται σωστά η CHUNK_GetNext, να δημιουργούμε συνεχώς το ίδιο chunk, κλπ. Με λίγη παρατηρητικότητα & ζωγραφική η τελική μας υλοποίηση ξεκαθαρίζει τα δύο αυτά.
        b. **Συνεργασία των συναρτήσεων του chunk.c:**
        Ο κώδικας του chatgpt δεν εκμεταλλευόταν τις υπάρχουσες συναρτήσεις κατάλληλα: για παράδειγμα στην CHUNK_GetIthRecordInChunk & στην CHUNK_UpdateIthRecord ταιριάζει σαν υλοποίηση να περιέχεται η CHUNK_GetNextRecord.


- Ο αλγόριθμος εξωτερικής ταξινόμησης υλοποιείται με δύο βασικά στάδια:
  1. **Ταξινόμηση chunks:** Τα δεδομένα χωρίζονται σε chunks και ταξινομούνται in-place.
  2. **Συγχώνευση chunks:** Εφαρμόζεται `b-way merge` έως ότου παραχθεί ένας ενιαίο chunk.
- Χρησιμοποιούνται σταθερές για τον αριθμό blocks ανά chunk και το μέγεθος των συγχωνεύσεων.
- Παραδοχές:
  - Τα δεδομένα ξεκινούν από το `block 1` (μεταδεδομένα στο `block 0`).
  - Η μνήμη RAM δεν επαρκεί για τη φόρτωση ολόκληρου του αρχείου.

## Οδηγίες Χρήσης
1. **Μεταγλώττιση:**
    make sort
2. **Εκτέλεση:**
    ./build/sort_main
    Η εκτέλεση της οποίας παράγει τα επιθυμητά αποτελέσματα:

    File ./test1.db has 512 blocks
    After the sort phase, file ./test1.db has 512 chunk(s)
    After the merge phase 1, the output file ./test1.db1.db has 256 chunk(s)
    After the merge phase 2, the output file ./test1.db2.db has 128 chunk(s)
    After the merge phase 3, the output file ./test1.db3.db has 64 chunk(s)
    After the merge phase 4, the output file ./test1.db4.db has 32 chunk(s)
    After the merge phase 5, the output file ./test1.db5.db has 16 chunk(s)
    After the merge phase 6, the output file ./test1.db6.db has 8 chunk(s)
    After the merge phase 7, the output file ./test1.db7.db has 4 chunk(s)
    After the merge phase 8, the output file ./test1.db8.db has 2 chunk(s)
    After the merge phase 9, the output file ./test1.db9.db has 1 chunk(s)
    File ./test2.db has 1280 blocks
    After the sort phase, file ./test2.db has 256 chunk(s)
    After the merge phase 1, the output file ./test2.db1.db has 64 chunk(s)
    After the merge phase 2, the output file ./test2.db2.db has 16 chunk(s)
    After the merge phase 3, the output file ./test2.db3.db has 4 chunk(s)
    After the merge phase 4, the output file ./test2.db4.db has 1 chunk(s)
3. **Διαγραφή παραγόμενων αρχείων .db:**
    rm *.db

## ΟΜΑΔΑ ΕΡΓΑΣΙΩΝ 6:
- sdi1900009 ΑΝΑΣΤΑΣΟΠΟΥΛΟΣ ΑΝΔΡΕΑΣ
- sdi2200025 ΓΑΛΙΑΤΣΑΤΟΥ ΕΛΕΥΘΕΡΙΑ
- sdi2200183 ΤΖΑΦΕΡΗΣ ΣΤΕΦΑΝΟΣ