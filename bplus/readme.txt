Για την δημιουργία του εκτελέσιμου για το B+ δέντρο, τρέξτε την εντολή:
make bp;

Για να τρέξετε το εκτελέσιμο:

./build/bp_main

# Σχολιασμος σχετικα με τις δυσλειτουργιες του προγραμματος παρουσιαζεται στο τελος της περιγραφης των συναρτησεων.

-BPLUS_INFO: Τα μεταδεδομενα του αρχείου για το δεντρο B+. Περιλαμβανει τον file descriptor αρχειου, το id της ριζας, το υψος του δεντρου(με height = 1
  το επιπεδο των block δεδομενων), το μεγεθος μια εγγραφης, το μεγεθος ενος κλειδιου κλπ

- BPLUS_DATA_NODE: στο struct αυτο αποθηκευονται τα μεταδεδομενα καθε κομβου δεδομενων(id του block, αριθμος εγγραφων, κλειδι μικροτερης εγγραφης, 
  id του γονεα, id του επομενου block δεδομενων) στην αρχη ενος block δεδομενων. Επιπλεον, εχουμε ορισει μια int μεταβλητη is_datanode, η οποια για κομβους 
  δεδομενων εχει τιμη 1, ενω για κομβους ευρετηριου εχει τιμη 0. Η δηλωση της βοηθαει στο να διατρεξουμε ολα τα blocks και να τα εκτυπωσοουμε αναλογα 
  με το αν ειναι data node ή index node. Μεσω της get data μπορουμε να παρουμε την τιμη αυτης της μεταβλητης, αποθηκευοντας τα πρωτα int bytes.
 
  βοηθητικές συναρτήσεις για την διαχείριση ενος block δεδομένων:

    - create_data_node: δημιουργει ενα νεο block δεδομενων και δεσμευει χωρο για αυτο στο αρχειο. Αρχικοποιει τα μεταδεδομενα του και τα αποθηκευει στην
    αρχη του block. Επισης, ενημερωνει τα μεταδεδομενα του αρχειου Β+ δεντρου καθως προστιθεται ενα block.

    - get_metadata_datanode: επιστρεφει τα μεταδεδομενα ενος μπλοκ δεδομενων

    - insert_rec_in_datanode: προσθετει μια εγγραφη στο block με id node που δινεται ως ορισμα. Εαν το block δεν εχει καμια εγγραφη, 
    εισαγεται απλα αμεσως μετα τα μεταδεδομενα, αλλιως εντοπιζεται η πρωτη εγγραφη με μεγαλυτερο κλειδι απο τη νεα και εισαγεται πριν απο αυτη. 
    Προκειμενου ολες οι επομενες εγγραφες να μετακινηθουν μια θεση δεξια, χρησιμοποιειται η memmove και ετσι η νεα εγγραφη εισαγεται στην καταλληληλη
    θεση. Εαν η εγγραφη προς εισαγωγη εχει το μεγαλυτερο κλειδι, προστιθεται στο τελος του block μετα απο ολες τις ηδη υπαρχουσες εγγραφες.

    - split_data_node: καλειται οταν θελουμε να εισαγουμε μια εγγραφη σε ενα block δεδομενων που δεν εχει ελευθερο χωρο. Ουσιαστικά, χωριζει το block στα δυο
    ισομοιραζοντας τις εγγραφες μαζι με την νεα. Αρχικά, ορίζει ενα νέο block μεσω της create_data_node και αρχικοποιει τα μεταδεδομενα του καταλληλα.
    Αφου εντοπισει σε ποια θεση πρεπει να εισαχθει η νεα εγγραφη, ελεγχει σε ποιο απο τα δυο μισα αντιστοιχει. Εαν είναι στο πρωτο μισο, η εγγραφη προστιθεται
    στο παλιο block, αλλιως στο νεο. Για τον σκοπο αυτο, πρωτα μετακινουνται οσες εγγραφες ειναι απαραιτητο στο νεο block και επειτα καλειται η
    insert_rec_in_datanode για το καταλληλο block (παλιο ή νεο). Μετά την εισαγωγή ενημερώνεται επίσης, το minKey καθε block

    - print_data_node: διατρεχει ενα block και αφου εκτυπωσει τα μεταδεδομενα του, εκτυπωνει μια μια τις εγγραφες με την σειρα που ειναι ταξινομημενες.

- BPLUS_INDEX_NODE: στο struct αυτο αποθηκευονται μεταδεδομενα σχετικά με ενα block ευρετηρίου. Αυτα περιλαμβλάνουν τα εξης: τον αριθμο κλειδιων που
 εχει το block, το id του block και το id του γονεα.

  Συναρτήσεις:
    - create_index_node: δημιουργει ενα νεο block ευρετηρίου και δεσμευει χωρο για αυτο στο αρχειο. Αρχικοποιει τα μεταδεδομενα του και τα αποθηκευει
     στην αρχη του block ευρετηρίου. Επισης, ενημερωνει τα μεταδεδομενα του αρχειου Β+ δεντρου καθως προστιθεται ενα block.
    
    - get_metadata_indexnode: επιστρέφει τα μεταδεδομενα ενος block ευρετηρίου.
    
    - insert_key_indexnode: εισαγει ενα ζευγος κλειδι - δεικτης στο index node που δινεται ως ορισμα και εχει χωρο. Εαν το index node ειναι κενο
      εισαγει το κλειδι και το left_child_id και right_child_id αριστερα κ δεξια αντιστοιχα απο το κλειδι. Εαν δεν ειναι κενο, εντοπιζεται η θεση που
      πρεπει να εισαχθει το κλειδι και μεταφερονται δυο θεσεις δεξια (δηλαδη κατα 2*sizeof(int) bytes), μεσω της memmove, τα δεδομενα απο τη θεση αυτη 
      και μετα. Επειτα, εισαγεται στη σωστη θεση το νεο κλειδι μαζι με τον δεικτη στο δεξιο παιδι. Αν το νεο κλειδι προς εισαγωγη ειναι το μεγιστο, 
      τοποθετειται στο τελος του block.    
    
    - split_index_node: Αναδρομικά σπάει ενα block ευρετηριου σε δυο, εισαγοντας το μεσαιο κλειδι στον γονεα. Αρχικα, αποθηκευουμε τα κλειδια σε εναν πινακα
    keys με number_of_keys + 1 θεσεις, με το +1 λογω του νεου κλειδιου. Ομοιως, αποθηκευουμε σε εναν αντιστοιχο πινακα τους δεικτες. Αφού, εντοπισουμε
    τη θεση pos στην οποια πρεπει να εισαχθει το νεο κλειδι κ αντιστοιχα ο νεος δεικτης, πρεπει να μετακινησουμε ολα τα στοιχεια και των δυο πινακων, μια 
    θεση δεξια απο το pos και επειτα. Ετσι, μπορουμε να εισαγουμε το κλειδι κ τον δεικτη στους δυο πινακες και να βρουμε το μεσαιο κλειδι παιρνοντας
    το στοιχειο keys[split_point] του πινακα. Τα πρωτα split_point στοιχεια εισαγονται στο αρχικο μπλοκ, ενω τα υπολοιπα (απο το keys[split_point + 1])
    εισαγονται στο νεο μπλοκ. Για το μεσαιο κλειδι υπαρχουν οι εξης περιπτωσεις: 1) αν ο γονεας υπαρχει και εχει χωρο, καλειται απλα η insert_key_indexnode
    2) αν ο γονεας υπαρχει και ειναι γεματος, καλειται αναδρομικα η split_index_node 3)Αν δεν υπαρχει ο γονεας (γιατι το μπλοκ που εσπασε ηταν η ριζα),
    καλειται η create_index_node, εισαγεται σε αυτο και ενημερωνεται η ριζα του δεντρου (αυξανεται το υψος).

    - update_parents: καλειται εσωτερικα της split_index_node προκειμενου να ενημερωσει τον γονεα των block που μεταφερονται στο νεο block ευρετηριου
    που προκυπτει. Δηλαδή, πλεον ο γονεας τους ειναι ο νεος κομβος index node που δημιουργει η split_index_node.
    
    - print_index_node: εκτυπωνει τα μεταδεδομενα ενος block ευρετηρίου και επειτα τους δεικτες με τα αντιστοιχα κλειδια στη σειρα που ειναι.
    
    - is_full_indexnode: επιστρεφει true αν το index node που δινεται ως ορισμα ειναι γεματο και false αν δεν ειναι.


  # ΠΑΡΑΤΗΡΗΣΕΙΣ 
  - Η υλοποιηση των συναρτησεων κρινουμε οτι είναι σωστή, όπως προκύπτει και απο τα αποτελέσματα των test μας. Ωστόσο, για 2325 εγγραφες
  παρουσιάζεται ένα πρόβλημα που δεν έχουμε καταφέρει να εντοπίσουμε την ακριβή αιτία του. Κατά την εισαγωγή της 2325ης εγγραφής με id 81 
  παρατηρείται μια περίεργη συμπεριφορά στην συναρτηση BP_GetEntry και συγκεκριμένα στη γραμμη 246 του αρχειου bp_file.c όπου καλείται η BF_GetBlock. 
  Το ύψος του δέντρου(bplus_info->height) τυπώνεται σωστά πριν καλεστεί η συναρτηση αυτή, ενώ αμέσως μετά φαίνεται να αλλάζει την τιμή του, 
  γεμίζοντας το σκουπίδια. Για οποιοδηποτε πληθος εγγραφων μεχρι και τον αριθμο 2024 λειτουργει σωστά το προγραμμα και η GetEntry επιστρέφει 
  σωστό αποτέλεσμα σχετικα με το αν μια εγγραφή βρέθηκε ή οχι. Έχουμε κρατήσει και τα αντίστοιχα μηνύματα εκτύπωσης σε σχόλια, ώστε να τα τρέξετε 
  αν χρειαστεί με αριθμό εγγραφών 2325 για τα test2 ή το bp_main που μας δοθηκε ετοιμο. Στο test2 εκτυπωνουμε και τους κομβους του δεντρου στο αρχειο
  output.txt. 
  Προκειμένου να αναδείξουμε την ορθή λειτουργία των συναρτήσεων μας, δημιουργήσαμε το test3 στο οποίο, ορίζουμε έναν μικρότερο αριθμό
  από κλειδία και εγγραφές που χωράνε κάθε μπλοκ ευρετηρίου και δεδομένων αντίστοιχα. Και αυτό επειδή, έτσι θα πραγματοποιηθούν περισσότερα 
  splits σε data & index node και το υψος του δεντρου μπορεί να φτάσει εως 5. 






